# ^行的开头.^\d表示以数字开头。\d表示数字开头，\w表示以数字或者字母开头
# $表示行的结尾。\d$表示以数字结尾
# 这里行首和行尾表示
# (A|B)表示匹配A or B
# \s表示空格
# 对于特殊字符,用\来转义
# []表示一个值，只能有一个值
# ()表示要提取的分组
# *表示0次或者多次


import re
if __name__ == '__main__':
    print(re.match(r'^\d{3}-\d{3,8}$','001-2335'))
    test='用户输入的正则表达式'
    if re.match(r'正则表达式',test):
        print('OK')
    else:
        print('Failed')
    print(re.match(r'^[0-9a-z]+\s+\d{0,9}py$','22 12py'))
    print(re.split(r'[\s]+','a b    d  c'))
    print(re.split(r'[\s\,\;]+','a,c,,ddd,p;ddd fff'))
    print(re.match(r'python','python is best'))
    m=re.match(r'^(\d{3})(-)(\d{3,9})$',"003-2222")
    # group(0)始终表示原始字符,分组的时候注意，先整体匹配，在通过()，来分割成小组
    print(m.group(0))
    print(m.group(1))
    print(m.group(2))
    print(m.group(3))
    # groups()表示打印所有的分组，通过元组表示
    print(m.groups())
    t='22:52:14'
    time=re.match(r'^(0[0-9]|1[0-9]|2[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:'
                  r'(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$',t)
    print(time.groups())
    # 正则表达式默认是贪婪匹配
    print(re.match(r'^(\d+)(0*)$','123400').groups())
    # 贪婪匹配后加上？表示非贪婪匹配，尽量少匹配,一般以后面表达式优先选择，后面的表达式，一般以$优先，按照贪婪匹配，没有$,
    # 后面的也按照前面的非贪婪匹配
    # 当一个表达式使用非贪婪匹配，那么后面的部分是否有$，有则先按照后面贪婪匹配，在决定前面的非贪婪，如果没有，那么后面和前面都是非贪婪
    # 匹配
    print(re.match(r'^(\d+?)(0*)$','23300').groups())

    pass